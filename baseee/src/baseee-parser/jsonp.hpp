/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * THIS FILE IS FROM Chhdao(sudo.free@qq.com)
 * IS LICENSED UNDER MIT
 * File:     jsonp.hpp
 * Content:  json parser head file
 * Copyright (c) 2020 Chhdao All rights reserved.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#pragma once

#include <string>
#include <string_view>
#include <vector>
#include <variant>
#include <optional>
#include <map>

namespace baseee {
	namespace parser {

		//Json类型
		enum class JsonType : int {
			JsonType_Null,
			JsonType_True,
			JsonType_False,
			JsonType_Number,
			JsonType_String,
			JsonType_Array,
			JsonType_Object
		};

		//Json数据结构
		class JsonData {
		public:
			std::variant<
				double,
				std::string,
				std::vector<JsonData>,
				std::multimap<std::string, JsonData>>
				Data = 0.0;
			JsonType JsonType = JsonType::JsonType_Null;
		};

		//解析器错误代码
		enum class JsonParserErrorCode : int {
			Parse_OK = 0,//正常
			Parse_UnknowError,//未知错误
			Parse_MissVulan,//无值
			Parse_VulanError,//值错误
			Parse_MissToken//找不到对应Token {} [] "" ,
		};

		using JsonErrCode = JsonParserErrorCode;

		//Json树
		class JsonTree {
		public:
			JsonTree() {}
			JsonTree(std::vector<JsonData> jt)
			{
				JsonObjectList = jt;
			}
			std::vector<JsonData> JsonObjectList;
		};


		//Json生成器
		class JsonBuilder {
		public:
			JsonBuilder() = default;

			void SetBeautiful(bool b) { BeautlfulFormat = b; }

			std::string Build(JsonTree jt);

		private:
			bool BeautlfulFormat = false;
			JsonTree BuildInfo;

			std::string BuildArray(JsonData JsonArray);
			std::string BuildObject(JsonData JsonObject);
			std::string BuildKeyVulanPair(std::pair<std::string, JsonData> Data);
		};

		//定位一个JsonTree元素的路径
		using JsonTreePath = JsonData*;

		//给用户使用的Json生成器
		//生成Tree供JsonBuilder生成文本
		class JsonTreeBuilder {
		public:
			//可以从0或者现有的JsonTree开始工作
			JsonTreeBuilder() { }
			JsonTreeBuilder(JsonTree jt) { JT = jt; }

			//获取根
			JsonTreePath GetRoot();

			/*以下操作均为在根下/子根进行*/
			//添加对象
			JsonTreePath AddNumber(JsonTreePath p,std::string_view name,double number);
			JsonTreePath AddBoolean(JsonTreePath p,std::string_view name,bool boolean);
			JsonTreePath AddString(JsonTreePath p,std::string_view name,std::string_view String);
			JsonTreePath AddNull(JsonTreePath p,std::string_view name);

			//添加Object
			JsonTreePath AddObject(JsonTreePath p, std::string_view name);

			//添加Array
			JsonTreePath AddNumberArray(
				JsonTreePath p, 
				std::string_view name, 
				double number[],
				size_t length);

			JsonTreePath AddBooleanArray(
				JsonTreePath p,
				std::string_view name,
				bool boolean[], 
				size_t length);

			JsonTreePath AddStringArray(
				JsonTreePath p,
				std::string_view name, 
				std::string_view String[],
				size_t length);

			JsonTreePath AddNullArray(
				JsonTreePath p,
				std::string_view name,
				size_t length);

			JsonTreePath AddJsonData(
				JsonTreePath p,
				std::string_view name,
				JsonData d);

			/*一些其他操作*/
			void DeleteJson(JsonTreePath p,std::string_view name);
			std::vector<JsonTreePath> GetChildrenList(JsonTreePath p);
			JsonTreePath GoChuild(JsonTreePath p,std::string_view name);
		private:
			JsonTree JT;
			JsonTreePath AddTo(JsonTreePath p, JsonData d, std::string_view name);
		};

		//Json解析器
		class JsonParser {
		public:
			JsonParser(const JsonParser&) = delete;

			JsonParser() { JsonNext.JsonType = JsonType::JsonType_Null; }
			~JsonParser() = default;

			JsonErrCode Parser(std::string_view JsonStr);

			JsonErrCode GetLastError() { return LastError; }

			JsonTree GetJsonTree() {
				return JsonTree(JsonPool);
			}

			//查找Object
			std::optional<baseee::parser::JsonData> 
				FindChildren(std::string_view Name);

		private:
			JsonErrCode LastError = JsonErrCode::Parse_OK;

			std::string Json;//Json字符串
			std::string::const_iterator Next;//Json解析流

			//Json对象池
			std::vector<JsonData> JsonPool;
			//当前构建的Json
			JsonData JsonNext;

			void AfterSpace();
			JsonErrCode ParseVulan();

			JsonErrCode ParseVulanNull();
			JsonErrCode ParseVulanBool();
			JsonErrCode ParseVulanTrue();
			JsonErrCode ParseVulanFalse();
			JsonErrCode ParseVulanNumber();
			JsonErrCode ParseVulanString();
			std::optional<std::string> ParseVulanUnicode();
			JsonErrCode ParseVulanArray();
			JsonErrCode ParseVulanObject();

			inline bool MatchCharRange(char a, char b);

			bool IteratorMatch(std::string_view str);
		};

	}
}